
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"> 
    <meta name="viewport" content="width=device-width, initial-scale=1">




<link
  href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/css/bootstrap.min.css"
  rel="stylesheet">

<style>
.julia {font-family: "Source Code Pro";
        color:#0033CC;
        }
body { padding-top: 60px; }
h5:before {content:"\2746\ ";}
h6:before {content:"\2742\ ";}
pre {display: block;}
</style>

<script src="https://code.jquery.com/jquery.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>

<!-- .julia:before {content: "julia> "} -->

<style></style>

<script src="https://cdn.plot.ly/plotly-latest.min.js"></script>


<!-- not TeX-AMS-MML_HTMLorMML-->
<script type="text/javascript"
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_SVG">  
</script>
<script>
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ["\$","\$"], ["\\(","\\)"]]
  },
  displayAlign: "left",
  displayIndent: "5%"
});
</script>


<script type="text/javascript">
$( document ).ready(function() {
  $("h1").each(function(index) { 
       var title = $( this ).text()
       $("#page_title").html("<strong>" + title + "</strong>");
       document.title = title
  });
  $( "h2" ).each(function( index ) {
    var nm =  $( this ).text();                                    
    var id = $.trim(nm).replace(/ /g,'');
    this.id = id
    $("#page_dropdown").append("<li><a href='#" + id + "'>" + nm + "</a></li>");
  });
  $('[data-toggle="popover"]').popover();  
});
</script>

</head>


<body data-spy="scroll" >

<nav class="navbar navbar-default  navbar-fixed-top">
  <div class="container-fluid">
    <!-- Brand and toggle get grouped for better mobile display -->
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
         
    </div>

    <!-- Collect the nav links, forms, and other content for toggling -->
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li><a href="#" id="page_title"></a></li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
         <li class="dropdown">
           <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
           Jump to... <span class="caret"></span></a>
          <ul class="dropdown-menu" role="menu" id="page_dropdown"></ul>
        </li>
      </ul>
    </div><!-- /.navbar-collapse -->
  </div><!-- /.container-fluid -->
</nav>

<header>
</header>

<div class="container-fluid">
  <div class="span10 offset1">
<h1>Newton's method</h1><h2>Bisection</h2><p>The bisection method has many advantages:</p><ul>
<li><p>given a bracket, can be guaranteed to converge</p>
</li>
<li><p>will find a root or the next best thing in floating point</p>
</li>
</ul><p>However, ...</p><ul>
<li><p>slow â€“ many steps</p>
</li>
<li><p>needs a bracket</p>
</li>
<li><p>won't work with roots of functions like $f(x) = (x-2)^2$</p>
</li>
</ul><h2>Newton's method</h2><p>See this <a href="http://calculuswithjulia.github.io/derivatives/newtons_method.html#Examples">algorithm</a></p><p>Basic idea: approximate function by tangent line and find that intersection.</p>    <div id="32610fed-be5b-48f5-841f-7bc0cf949e5b" style="width:600px;height:400px;"></div>
    <script>
    PLOT = document.getElementById('32610fed-be5b-48f5-841f-7bc0cf949e5b');
    Plotly.plot(PLOT, [{"xaxis":"x1","colorbar":{"title":""},"yaxis":"y1","text":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"x":[1.0195316380395762,1.0390632760791525,1.058594914118729,1.0781265521583052,1.2587247484554744,1.4393229447526439,1.6199211410498133,1.8005193373469828,2.0175833138959867,2.234647290444991,2.4181721200855586,2.6016969497261258,3.0004157602644113,3.3679992362770252,3.7620875712519184,4.2186775547082584,4.624440848888171,4.98025869232176,5.368195653242556,5.758438230022497,6.189901300995234,6.6004275259587475,7.027279548090804,7.3865980293347615,7.825285167890913,8.237664017029667,8.89832691212848],"showlegend":true,"mode":"lines","name":"y1","zmin":-0.1,"legendgroup":"y1","zmax":0.1,"line":{"color":"rgba(0, 154, 250, 1.000)","shape":"linear","dash":"solid","width":1},"y":[-1.9806566565510737,-1.961680388794898,-1.9430575239163532,-1.9247751390803831,-1.7699008959605365,-1.6358271742351838,-1.51762253030485,-1.4119248559636641,-1.2980995840792797,-1.1959165962695089,-1.1169880675096935,-1.0438360948993504,-0.9012491341793436,-0.7856811303785485,-0.6750259915473444,-0.5604782967260431,-0.46864453388200067,-0.3945181640632487,-0.31950815292431334,-0.24933370267855848,-0.17708085834253362,-0.11286557640512118,-0.05020034658452288,-0.0003327188897663813,0.057360178943127504,0.10871681065069749,0.18586327166495353],"type":"scatter","hoverinfo":"text"},{"xaxis":"x1","colorbar":{"title":""},"yaxis":"y1","text":[null,null],"x":[1,9],"showlegend":true,"mode":"lines","name":"y2","zmin":-0.1,"legendgroup":"y2","zmax":0.1,"line":{"color":"rgba(0, 0, 0, 1.000)","shape":"linear","dash":"solid","width":1},"y":[0,0],"type":"scatter","hoverinfo":"text"},{"xaxis":"x1","colorbar":{"title":""},"yaxis":"y1","text":[null,null,null,null,null,null,null],"x":[1.5,1.5,3.8918023378377535,3.8918023378377535,6.386944322799028,6.386944322799028,7.317803409083361],"showlegend":true,"mode":"lines","name":"y3","zmin":-0.1,"legendgroup":"y3","zmax":0.1,"line":{"color":"rgba(255, 165, 0, 1.000)","shape":"linear","dash":"solid","width":1},"y":[0.0,-1.5945348918918356,0.0,-0.6411276237496559,0.0,-0.14574404272814934,0.0],"type":"scatter","hoverinfo":"text"},{"xaxis":"x1","colorbar":{"title":""},"yaxis":"y1","text":[null,null,null,null],"x":[1.5,3.8918023378377535,6.386944322799028,7.317803409083361],"showlegend":true,"mode":"markers","name":"y4","zmin":-0.1,"legendgroup":"y4","marker":{"symbol":"circle","color":"rgba(255, 165, 0, 1.000)","line":{"color":"rgba(0, 0, 0, 1.000)","width":1},"size":10},"zmax":0.1,"y":[0.0,0.0,0.0,0.0],"type":"scatter","hoverinfo":"text"}], {"showlegend":false,"xaxis":{"showticklabels":true,"gridwidth":0.5,"tickvals":[2.0,4.0,6.0,8.0],"visible":true,"ticks":"inside","range":[0.76,9.24],"domain":[0.0658209390492855,0.9934383202099738],"tickmode":"array","linecolor":"rgba(0, 0, 0, 1.000)","showgrid":true,"title":"","mirror":false,"tickangle":0,"showline":true,"gridcolor":"rgba(0, 0, 0, 0.100)","titlefont":{"color":"rgba(0, 0, 0, 1.000)","family":"sans-serif","size":15},"tickcolor":"rgb(0, 0, 0)","ticktext":["2","4","6","8"],"zeroline":false,"type":"-","tickfont":{"color":"rgba(0, 0, 0, 1.000)","family":"sans-serif","size":11},"zerolinecolor":"rgba(0, 0, 0, 1.000)","anchor":"y1"},"paper_bgcolor":"rgba(255, 255, 255, 1.000)","annotations":[],"height":400,"margin":{"l":0,"b":20,"r":0,"t":20},"plot_bgcolor":"rgba(255, 255, 255, 1.000)","yaxis":{"showticklabels":true,"gridwidth":0.5,"tickvals":[-2.0,-1.5,-1.0,-0.5,0.0],"visible":true,"ticks":"inside","range":[-2.0456522543975546,0.2508588695114343],"domain":[0.03762029746281716,0.9901574803149606],"tickmode":"array","linecolor":"rgba(0, 0, 0, 1.000)","showgrid":true,"title":"","mirror":false,"tickangle":0,"showline":true,"gridcolor":"rgba(0, 0, 0, 0.100)","titlefont":{"color":"rgba(0, 0, 0, 1.000)","family":"sans-serif","size":15},"tickcolor":"rgb(0, 0, 0)","ticktext":["-2.0","-1.5","-1.0","-0.5","0.0"],"zeroline":false,"type":"-","tickfont":{"color":"rgba(0, 0, 0, 1.000)","family":"sans-serif","size":11},"zerolinecolor":"rgba(0, 0, 0, 1.000)","anchor":"x1"},"width":600});
    </script>
<p>More formally, Let $r$ be a zero of $f(x)$. Further, suppose $r$ is a <em>simple</em> zero where $f'(r) \neq 0$.</p><p>Suppose $x$ is an approximation to $r$. That is, suppose $r = x + h$ for some small $h$, then using Taylor's theorem about $x$, we have:</p>$$~
0 = f(r) = f(x+h) = f(x) + f'(x) \cdot h + \mathcal{O}(h^2)
~$$
<h3></h3><p>If we were to just ignore the error term and solve for $h$, we would get:</p>$$~
h \approx -f(x)/f'(x)
~$$
<p>So $r = x + h \approx x - f(x)/f'(x)$. (Not necessarily exactly, but this should be closer.)</p><h3></h3><p>Iterating the above process yields this algorithm:</p>$$~
x_{n+1} = x_n - f(x_n) / f'(x_n), \quad x_0 \text{ should be near answer}
~$$
<h3>Example</h3><p>Solve $x - 2\sin(x) - 1 = 0$ near $2$.</p><p>Start with $x = 2$. We note that $f'(x) = 1 - 2\cos(x)$</p><pre class="sourceCode julia">f(x) = x - 2sin(x) - 1
fp(x) = 1 - 2cos(x)
x = 2
x = x - f(x) / fp(x)</pre>
<pre class="output">
2.4467596355713885</pre>

<pre class="sourceCode julia">x = x - f(x) / fp(x)</pre>
<pre class="output">
2.3812138074297873</pre>

<pre class="sourceCode julia">x = x - f(x) / fp(x)</pre>
<pre class="output">
2.380061647086649</pre>

<pre class="sourceCode julia">x = x - f(x) / fp(x)</pre>
<pre class="output">
2.3800612731393787</pre>

<pre class="sourceCode julia">x = x - f(x) / fp(x)</pre>
<pre class="output">
2.380061273139339</pre>

<pre class="sourceCode julia">x = x - f(x) / fp(x)</pre>
<pre class="output">
2.380061273139339</pre>

<h3>Termination</h3><p>When do we stop?</p><ul>
<li><p>We stopped when the method stabilized to 16 <em>or so</em> digits</p>
</li>
<li><p>There is no guarantee it will stabilize though, so we should guard against that</p>
</li>
<li><p>The goal is to solve $f(r) = 0$, so finding values where $f(r)$ is close to $0$ should also be a good criteria</p>
</li>
</ul><h3>Let's implement it...</h3><pre class="sourceCode julia">function nm(f, fp, x)
  ## Fill me in...
end</pre>
<pre class="output">
nm (generic function with 1 method)</pre>

<h3>Programming a stopping value</h3><p>The basic algorithm is simple:</p><p>As long as we have not converged or tried to many times, just update $x$ via <code>x &#61; x - f&#40;x&#41; / fp&#40;x&#41;</code>.</p><p>The book (p82) has these stopping criteria for converging:</p><p>Either</p>$$~
|x_{n+1} - x_n| \leq \delta, \quad \text{ or } |f(x_{n+1})| \leq \epsilon
~$$
<p>The first says stop if the <code>x</code>'s don't change much. This is what we see in the output. The second says stop if the function value is small.</p><p>But this isn't really enough. First, we should add in a bound on the number of steps.  But, let's look at the latter point. It says stop if the function value should be close to 0. But what is close to zero? Answer: it depends on $x$!</p><h3></h3><p>We have in general $f(fl(x)) = f(x\cdot(1 + \delta)) \approx f(x) + f'(x) x \delta$. This value depends on $x$! So, it is not unusual to have a third tolerance depending on $x$. For example, this check on convergence comes from <code>quadgk</code>:</p><blockquote>
<p><code>while E &gt; abstol &amp;&amp; E &gt; reltol * nrm&#40;I&#41; &amp;&amp; numevals &lt; maxevals</code></p>
</blockquote><p><code>E</code> is the error and <code>numevals</code> the number of evaluations. The <code>nrm&#40;I&#41;</code> is <em>basically</em> $|x|$. So this checks that $E$ isn't small and $E$ is not small relative to $|x|$ and the number of evaluations is still small.</p><h3>leading to...</h3><pre class="sourceCode julia">function nm(f, fp, x; atol=eps(), rtol=1e-12, maxsteps=100)
   cnt = 0
   while cnt < maxsteps && abs(f(x)) >= atol + abs(x) * rtol
     x = x - f(x) / fp(x)
     cnt = cnt + 1
  end

  cnt == maxsteps && error("too many steps")
  x
end</pre>
<pre class="output">
nm (generic function with 1 method)</pre>

<pre class="sourceCode julia">f(x) = x^5 - x - 1; fp(x) = 5x^4 - 1
nm(f, fp, 1)</pre>
<pre class="output">
1.1673039782614396</pre>

<h3>made for floating point not exact math</h3><p>Look at finding the square root of 2 starting at 2. We use $f(x) = x^2 - 2$, so $x - f(x)/f'(x) = x - (x^2-2)/(2x) = x/2 - 1/x$</p><pre class="sourceCode julia">x = 2//1
x = x/2 + 1/x</pre>
<pre class="output">
3//2</pre>

<pre class="sourceCode julia">x = x/2 + 1/x</pre>
<pre class="output">
17//12</pre>

<pre class="sourceCode julia">x = x/2 + 1/x</pre>
<pre class="output">
577//408</pre>

<pre class="sourceCode julia">x = x/2 + 1/x</pre>
<pre class="output">
665857//470832</pre>

<pre class="sourceCode julia">x = x/2 + 1/x</pre>
<pre class="output">
886731088897//627013566048</pre>

<pre class="sourceCode julia">x = x/2 + 1/x</pre>
<pre class="output">
OverflowError("886731088897 * 886731088897 overflowed for type Int64")
</pre>

<p>The floating point doesn't go crazy, the digits just get refined.</p><h3>Special cases are quite old</h3><p>The <a href="https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method">Babylonian</a> method is this algorithm:</p>$$~
x_{n+1} = \frac{1}{2}(x_n + \frac{S}{x_n}).
~$$
<p>It converges to solutions of $x^2 - S = 0$:</p>$$~
x - \frac{x^2 - S}{2x} = x - \frac{x}{2} + \frac{S}{2x} = \frac{x}{2} + \frac{S}{2x} = \frac{1}{2}(x + \frac{S}{x})
~$$
<h2>Analysis</h2><p>Let $f(x)$ be our function and $r$ our root. Define $e_n = x_n - r$. We have the following expansion about $x_n$:</p>$$~
f(x) = f(x_n) + f'(x_n) \cdot (x - x_n) + f''(\xi)/2 \cdot (x - x_n)^2
~$$
<p>Using $r$ for $x$ gives:</p>$$~
0 = f(r) = f(x_n) + f'(x_n) \cdot (r - x_n) + f''(\xi)/2 \cdot (r - x_n)^2
~$$
<p>Divide by $f'(x_n)$</p>$$~
0 = f(x_n)/f'(x_n) + (r - x_n) + \frac{1}{2}\frac{f''(\xi)}{f'(x_n)}(e_n)^2.
~$$
<p>and rearrange:</p>$$~
x_n - f(x_n)/f'(x_n) -r = \frac{1}{2}\frac{f''(\xi)}{f'(x_n)}(e_n)^2.
~$$
<p>But this is just</p>$$~
e_{n+1} = \frac{1}{2}\frac{f''(\xi)}{f'(x_n)}(e_n)^2.
~$$
<h3>Theorem 1 (p85)</h3><blockquote>
<p>Let $f$ be $C^2$ and $r$ be a simple zero of $f$, then there is a <em>neighborhood</em> of $r$ and a constant $C$ such that</p>
</blockquote>$$~
|e_{n+1}| \leq C \cdot e_n^2.
~$$
<h3>Typical convergence</h3><p>The term on the right is <em>basically</em> $1/2 \cdot f''(r)/f'(r)$. If this is bounded and $e_n$ goes to zero, we have <em>quadratic convergence</em>.</p><p>We basically need:</p><ul>
<li><p>the function $f''$ is not too big near $r$</p>
</li>
<li><p>the function $f'$ is not too small near $r$</p>
</li>
<li><p>the function $e_0$ not too far off.</p>
</li>
</ul><h3>A function which has problems</h3><p>Wilkinson proposed this function $f(x) = x^{20} - 1$ to test Newton's method for a root $r=1$. Why?</p><p>Notice $f''(x) = 20 \cdot 19 \cdot x^{18}$ is large if $x > 1$ ($f''(1.1) = 2112.\dots$)</p><p>But $f'(x) = 20 x^{19}$ is <em>small</em> when $x < 1$!. $f'(0.5) = 1.9\cdot 10^{-6}$.</p><p>So the Newton algorithm will have trouble</p><pre class="sourceCode julia">using Roots
f(x) = x^20 - 1
newton(f,f', 0.5)</pre>
<pre class="output">
Roots.ConvergenceFailed("Stopped at: xn = 3368.930120334614")
</pre>

<p>If $x_0 = 0.5$ we have $C$ may be as big as: (Depends if $\xi$ is near $1$ or $0.5$.</p><pre class="sourceCode julia">1/2 * f''(1) / f'(0.5)</pre>
<pre class="output">
4.980736e6</pre>

<p>And after an iteraction, we have $x_n > 1$, so then the second derivative is big. In this case, $x_1=26214$ so the second derivative is <strong>huge</strong>.</p><h3>What can guarantee convergence?</h3><p>Suppose we have $f$ is $C^2$. If the above assumptions on $f$ are true, for $\delta > 0$, we have in the ball around $r$ of size $\delta$ (for some sufficiently small $\delta$ that</p>$$~
c(\delta) = \frac{1}{2} \max|f''(x)| / \min |f'(y)|
~$$
<p>Satisfies $\delta \cdot c(\delta) = \rho < 1$. If we start within $\delta$ of $r$, then we have:</p>$$~
|e_1| = |\frac{1}{2}\frac{f''(\xi_1)}{f'(x_0)} e_0^2 \leq c(\delta) |e_0|^2 \leq c(\delta) \delta |e_0| < \rho |e_0|.
~$$
<p>Iterating, we can get</p>$$~
|e_n| \leq \rho^n |e_0| \rightarrow 0
~$$
<p>.</p><p>(Note all three things were used!)</p><h2>Theorem 2 (p86) Guaranteed convergence</h2><blockquote>
<p>If $f$ is $C^2$ and <em>concave up</em> and <em>increasing</em> and has a zero, then it is unique and Newton's method would converge from any starting point.</p>
</blockquote><p>Why? We have $f' > 0$ and $f'' > 0$ by assumption.</p><p>So, from $e_{n+1} = 1/2 f''(\xi)/f'(x_n) e_n^2$ we get $e_{n+1} \geq 0$. This implies $x_n > r$ for $n \geq 1$.</p><p>But $e_{n+1} = e_n - f(x_n)/f'(x_n) \leq e_n$ (as $f' > 0$ and $f(x_n) > f(r) = 0$ for $n \geq 1$.</p><p>We must have $e_n \rightarrow L \geq 0$, and hence $x_n \rightarrow x = r + L$. Is $L=0$?</p><p>But then $L = L - f(x)/f'(x)$ so $f(x) = 0$, or $x = r$.</p><h3>Roots with multiplicity</h3><p>Why did we need to assume "simple zero"? A simple zero means $f'(r)$ is non-zero.</p><p>A zero has multiplicity $k$ if $f(x) = (x-r)^k g(x)$ where $g(r)$ is non-zero. For a zero of multiplicity $k$, $f(r)$, $f'(r), \cdot f^{(k-1)}(r)$ are all 0.</p><p>Suppose for simplicity $g(x) = f(x)^k$, for some $k > 1$ where $f$ has a simple 0 at $r$. Then "Newton's method" for $g$ becomes:</p>$$~
x_{n+1} = x_n - \frac{1}{k}\frac{f(x_n)}{f'(x_n)}.
~$$
<p>So, not the same. The expansion around $x_n$ does not cancel off the same way.</p><h3>Rather</h3>$$~
x_{n+1} - r = (x_n - r) - \frac{1}{k}(x_n-r + \frac{f''(\xi)}{2f'(x_n)}(x_n-r)^2) =
\frac{k-1}{k} (x_n-r) + \frac{f''(\xi)}{2kf'(x_n)}(x_n-r)^2.
~$$
<p>That is</p>$$~
e_{n+1} = \frac{k-1}{k} e_n + \frac{f''(\xi)}{2f'(x_n)}e_n^2 = \mathcal{O}(e_n)
~$$
<p>And not $\mathcal{O}(e_n^2)$.</p><p>That is, as $k > 1$, the $(x_n - r)$ term dominates, and we see the convergence is linear with $\lvert e_{n+1}\rvert \approx (k-1)/k \lvert e_n\rvert$.</p><h3>Example</h3><pre class="sourceCode julia">using Roots
f(x) = cos(x) - x
g(x) = f(x)^4
newton(g,g', 0.7, verbose=true)</pre>
<pre class="output">
0.7389932543606224</pre>

<h2>Application: division through multiplication</h2><p><a href="http://tinyurl.com/kjj9w92">Newton-Raphson Division</a> is a means to divide by multiplying.</p><p>Why would you want to do that? Well, even for computers division is harder (read slower) than multiplying. The trick is that $p/q$ is simply $p \cdot (1/q)$, so finding a means to compute a reciprocal by multiplying will reduce division to multiplication.  (This trick is used by <a href="http://www.yeppp.info/resources/ppam-presentation.pdf">yeppp</a>, a high performance library for computational mathematics.)</p><h3></h3><p>Well suppose we have $q$, we could try to use Newton's method to find $1/q$, as it is a solution to $f(x) = x - 1/q$. The Newton update step simplifies to:</p>$$~
x - f(x) / f'(x) \quad\text{or}\quad x - (x - 1/q)/ 1 = 1/q
~$$
<p>That doesn't really help, as Newton's method is just $x_{i+1} = 1/q$ â€“ that is it just jumps to the answer, the one we want to compute by some other means!</p><h3></h3><p>Trying again, we simplify the update step for a related function: $f(x) = 1/x - q$ and then one step of the process is:</p>$$~
x_{i+1} = -qx^2_i + 2x_i.
~$$
<p>Now for $q$ in the interval $[1/2, 1]$ we want to get a <em>good</em> initial guess. Here is a claim. We can use $x_0=48/17 - 32/17 \cdot q$. Let's check graphically that this is a reasonable initial approximation to $1/q$:</p><pre class="sourceCode julia">using Plots
g(q) = 1/q
h(q) = 1/17 * (48 - 32q)
plot(g, 1/2, 1)
plot!(h)</pre>
    <div id="a0c2e359-4d61-4e8b-b5ee-8f29ff962d3c" style="width:600px;height:400px;"></div>
    <script>
    PLOT = document.getElementById('a0c2e359-4d61-4e8b-b5ee-8f29ff962d3c');
    Plotly.plot(PLOT, [{"xaxis":"x1","colorbar":{"title":""},"yaxis":"y1","text":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"x":[0.504882909509894,0.5500324585841865,0.5771654556528119,0.6001060593578829,0.6250259850165257,0.6479999522673141,0.672630473203245,0.7011673471692661,0.7265275530555108,0.74876616827011,0.7730122283276597,0.7974023893764061,0.8243688313122021,0.8500267203724217,0.8767049717556753,0.8991623768334226,0.926580322993182,0.9523540010643542,0.99364543200803],"showlegend":true,"mode":"lines","name":"y1","zmin":-0.1,"legendgroup":"y1","zmax":0.1,"line":{"color":"rgba(0, 154, 250, 1.000)","shape":"linear","dash":"solid","width":1},"y":[1.9806572596619125,1.8180745234091358,1.7326054257161574,1.666372109406804,1.5999334811232846,1.5432099902184533,1.4867004095692162,1.4261930536799425,1.376410290008085,1.3355304264218038,1.2936405962987252,1.2540719883997735,1.213049259041289,1.1764336061834275,1.1406345717390152,1.112146177113968,1.079237250333189,1.0500297146674413,1.0063952067682012],"type":"scatter","hoverinfo":"text"},{"xaxis":"x1","colorbar":{"title":""},"yaxis":"y1","text":[null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null],"x":[0.4952795901536242,0.5420624940434577,0.5701770692746732,0.5939475848238567,0.6197690273616715,0.6435741134344753,0.6690956815858234,0.6986649211339725,0.7249425717180425,0.7479857032566467,0.7731089020623098,0.7983814149355504,0.8263234096442295,0.852909512551816,0.8805528909686829,0.9038227274323549,0.9322325602290906,0.9589386409943071,1.001723853358955],"showlegend":true,"mode":"lines","name":"y2","zmin":-0.1,"legendgroup":"y2","zmax":0.1,"line":{"color":"rgba(227, 111, 71, 1.000)","shape":"linear","dash":"solid","width":1},"y":[1.8912384185343545,1.80317648180055,1.7502549284241447,1.705510428566858,1.656905360260383,1.6120957864762817,1.5640551876031559,1.508395442571346,1.458931629707214,1.4155563232816062,1.3682655961180052,1.3206938071801404,1.268097111257921,1.2180526822554052,1.1660180875883615,1.1222160424802732,1.0687387101570058,1.0184684404813042,0.9379315701478494],"type":"scatter","hoverinfo":"text"}], {"showlegend":true,"xaxis":{"showticklabels":true,"gridwidth":0.5,"tickvals":[0.5,0.6000000000000001,0.7000000000000001,0.8,0.9,1.0],"visible":true,"ticks":"inside","range":[0.4800862622574643,1.016917181255115],"domain":[0.05100612423447069,0.9934383202099737],"tickmode":"array","linecolor":"rgba(0, 0, 0, 1.000)","showgrid":true,"title":"","mirror":false,"tickangle":0,"showline":true,"gridcolor":"rgba(0, 0, 0, 0.100)","titlefont":{"color":"rgba(0, 0, 0, 1.000)","family":"sans-serif","size":15},"tickcolor":"rgb(0, 0, 0)","ticktext":["0.5","0.6","0.7","0.8","0.9","1.0"],"zeroline":false,"type":"-","tickfont":{"color":"rgba(0, 0, 0, 1.000)","family":"sans-serif","size":11},"zerolinecolor":"rgba(0, 0, 0, 1.000)","anchor":"y1"},"paper_bgcolor":"rgba(255, 255, 255, 1.000)","annotations":[],"height":400,"margin":{"l":0,"b":20,"r":0,"t":20},"plot_bgcolor":"rgba(255, 255, 255, 1.000)","yaxis":{"showticklabels":true,"gridwidth":0.5,"tickvals":[1.0,1.2000000000000002,1.4000000000000001,1.6,1.8,2.0],"visible":true,"ticks":"inside","range":[0.9066497994624275,2.0119390303473343],"domain":[0.03762029746281716,0.9901574803149606],"tickmode":"array","linecolor":"rgba(0, 0, 0, 1.000)","showgrid":true,"title":"","mirror":false,"tickangle":0,"showline":true,"gridcolor":"rgba(0, 0, 0, 0.100)","titlefont":{"color":"rgba(0, 0, 0, 1.000)","family":"sans-serif","size":15},"tickcolor":"rgb(0, 0, 0)","ticktext":["1.0","1.2","1.4","1.6","1.8","2.0"],"zeroline":false,"type":"-","tickfont":{"color":"rgba(0, 0, 0, 1.000)","family":"sans-serif","size":11},"zerolinecolor":"rgba(0, 0, 0, 1.000)","anchor":"x1"},"legend":{"tracegroupgap":0,"bordercolor":"rgba(0, 0, 0, 1.000)","bgcolor":"rgba(255, 255, 255, 1.000)","font":{"color":"rgba(0, 0, 0, 1.000)","family":"sans-serif","size":11},"y":1.0,"x":1.0},"width":600});
    </script>
<h3></h3><p>It can be shown that we have for any $q$ in $[1/2, 1]$ with initial guess $x_0 = 48/17 - 32/17\cdot q$ that Newton's method will converge to 16 digits in no more than this many steps:</p>$$~
\log_2(\frac{53 + 1}{\log_2(17)}).
~$$
<pre class="sourceCode julia">a = log2((53 + 1)/log2(17))
ceil(Integer, a)</pre>
<pre class="output">
4</pre>

<p>That is 4 steps suffices.</p><h3>Why?</h3><p>We can get a slightly bigger bound by estimating:</p>$$~
|e_{n+1}| \leq \frac{f''(\xi)}{2f'(x_n)} e_n^2 \leq \frac{4}{2\cdot 1} e_n^2
~$$
<p>But $|e_0| \leq 1/17$, so we get</p><pre class="sourceCode julia">e0 = 1/17
e1 = 2*e0^2; e2 = 2*e1^2; e3 = 2*e2^2; e4 = 2*e3^2; e5 = 2*e4^2;
e1, e2, e3, e4, e5</pre>
<pre class="output">
(0.006920415224913495, 9.578429377042899e-5, 1.8349261866199686e-8, 6.7339082206874e-16, 9.06910398492827e-31)</pre>

<p>So between 4 and 5 steps, so 5 steps would suffice.</p><p>(The better answer comes from computing that in this case this is exact: $e_{n+1} = e_n^2$.)</p><h3>Let's see...</h3><p>For $q = 0.80$, to find $1/q$ using the above we have</p><pre class="sourceCode julia">q = 0.80
x = (1/17) * (48 - 32q)
x = -q*x*x + 2*x
x = -q*x*x + 2*x
x = -q*x*x + 2*x
x = -q*x*x + 2*x</pre>
<pre class="output">
1.25</pre>

<p>Timing this shows the method to be similar to  a regular division.</p>
  </div>
</div>  

</body>
</html>
